

local function EncodeMessage(Message,Seed)

	local function IsValid(Chosen,Order)
		for i,v in pairs(Order) do 
			if v == Chosen then return false end
		end
		return true
	end

	local random
	if not Seed then
		random = Random.new(tick())
	else
		random = Random.new(Seed)
	end
	Seed = tick()
	local BaseOrder = {}
	local Index = 0 
	for i = 0, 255 do 
		Index = Index + 1
		local Char = string.char(i)
		if not BaseOrder[Char] then
			local Valid = false
			local Chosen = random:NextInteger(1,255)
			while not Valid do 
				if IsValid(Chosen,BaseOrder) then 
					BaseOrder[Char] = Chosen
					Valid = true
				else
					Chosen = random:NextInteger(1,255)
				end
			end
		end
	end
	local EncodedMessage = ''
	if typeof(Message) == 'string' then
		for i = 1, string.len(tostring(Message)) do 
			local Char = string.sub(Message,i,i)
			if BaseOrder[Char] then
				EncodedMessage = EncodedMessage .. BaseOrder[Char] .. '/'
			end
		end

	elseif typeof(Message) == 'table' then
		EncodedMessage = {}
		for i,v in pairs(Message) do 
			local NewIndex = ''
			local NewValue = ''
			for I = 1, string.len(tostring(i)) do 
				local IndexChar = string.sub(i,I,I)
				if BaseOrder[IndexChar] then
					NewIndex = NewIndex .. BaseOrder[IndexChar] .. '/'
				end
			end
			for I = 1, string.len(tostring(v)) do 
				local ValueChar = string.sub(v,I,I)
				if BaseOrder[ValueChar] then
					NewValue = NewValue .. BaseOrder[ValueChar] .. '/'
				end
			end
			EncodedMessage[NewIndex] = NewValue
		end
	end
	BaseOrder = {123}
	warn(EncodedMessage)
	return EncodedMessage,Seed
end

local function DecodeMessage(Message,Seed)
	local function IsValid(Chosen,Order)
		for i,v in pairs(Order) do 
			if i == Chosen then return false end
		end
		return true
	end

	local random
	if not Seed then
		random = Random.new(tick())
	else
		random = Random.new(Seed)
	end
	local BaseOrder = {}
	local Index = 0 
	for i = 0, 255 do 
		Index = Index + 1
		local Char = string.char(i)
		if not BaseOrder[Char] then
			local Valid = false
			local Chosen = random:NextInteger(0,255)
			while not Valid do 
				if IsValid(Chosen,BaseOrder) then 
					BaseOrder[Chosen] = Char
					Valid = true
				else
					Chosen = random:NextInteger(0,255)
				end
			end
		end
	end
	local DecodedMessage = ''
	if typeof(Message) == 'string' then
		for i,v in ipairs(string.split(Message,'/')) do 
			if tonumber(v) then
				DecodedMessage = DecodedMessage .. BaseOrder[tonumber(v)]
			end
		end
	elseif typeof(Message) == 'table' then
		DecodedMessage = {}
		for i,v in pairs(Message) do 
			local NewIndex = ''
			local NewValue = ''
			for Index,Value in ipairs(string.split(i,'/')) do 
				local Char = BaseOrder[tonumber(Value)]
				if Char then
					NewIndex = NewIndex .. Char
				end
			end
			for Index,Value in ipairs(string.split(v,'/')) do 
				local Char = BaseOrder[tonumber(Value)]
				if Char then
					NewValue = NewValue .. Char
				end
			end
			DecodedMessage[NewIndex] = NewValue
		end
	end
	BaseOrder = {123}
	return DecodedMessage
end

local AES_Server = require(game.ServerScriptService.Lib.AES_Server)

local function DecryptMessage(Player,Args,EncodedKey)
	local EncodedMessage = Args[1]
	local EncodedSeed = Args[2]
	math.randomseed(Player.AccountAge)
	local Num = math.random(1,100)
	EncodedSeed = EncodedSeed / Player.AccountAge
	local Seed = EncodedSeed * Num
	if string.find(Seed,'.9999') then
		Seed = Seed + .1
	end
	Seed = math.floor(Seed)
	local r = AES_Server:DecodeMessage(EncodedKey,Seed)
	if not tonumber(r) then
		r = AES_Server:DecodeMessage(EncodedKey, Seed + 1)
	end
	if not tonumber(r) then
		r = AES_Server:DecodeMessage(EncodedKey,Seed - 1)
	end
	if not tonumber(r) then
		Args[2] = Args[2] + .1
		return DecryptMessage(Player,Args,EncodedKey)
	end
	local EncryptedMessage = AES_Server:DecodeMessage(EncodedMessage,Seed)
	local DecryptedMessage = AES_Server.new(EncryptedMessage,'Decrypt',r)

	return DecryptedMessage
end
local a = false
game.ReplicatedStorage.Pulse.Events.Call.OnServerInvoke = function(Player,Args,EncodedKey)
	if a then return end
	local Message = DecryptMessage(Player,Args,EncodedKey) -- This function returns the Decrypted values of what was sent if information is valid
	warn(Message)
end




