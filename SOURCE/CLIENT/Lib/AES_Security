local module = {}
local AES_Storage = require(game.ReplicatedStorage.Pulse.Lib.AES_ClientStorage)
function module:Auth()
	local RealAuth = function()
		if debug.info(1,'s') ~= script:GetFullName() then
			return false
		end
		local Main1 = string.split(debug.traceback('',1),'\n')
		local Main2 = string.split(debug.traceback('',2),'\n')
		for i,v in ipairs(Main1) do 
			if v == '' then
				table.remove(Main1,i)
			end
		end
		for i,v in ipairs(Main2) do 
			if v == '' then
				table.remove(Main2,i)
			end
		end
		if Main2[1] ~= script:GetFullName() .. ':1' then return false end
		if Main1[1] ~= script:GetFullName() .. ':1' or Main1[2] ~= script:GetFullName() .. ':1' then  return false end
		if not string.find(debug.traceback('',1),'function new') then  return false end
		if not string.find(debug.traceback('',2),'function new') then return false end
		return true
	end

	return RealAuth
end

local function EncodeMessage(message,BaseOrder)
	local NewMessage 
	
	if typeof(message) == 'table' then
		NewMessage = {}
		for i,v in pairs(message) do 
			local newIndex = ''
			local newValue = ''
			if typeof(i) == 'table' then
				newIndex = EncodeMessage(i,BaseOrder)
			else
				for I = 1, string.len(tostring(i)) do 
					local Char = string.sub(i,I,I)
					if BaseOrder[Char] then
						newIndex = newIndex .. BaseOrder[Char] .. '/'
					end
				end
			end
			if typeof(v) == 'table' then
				newValue = EncodeMessage(v,BaseOrder)
			else
				for I = 1, string.len(tostring(v)) do 
					local Char = string.sub(v,I,I)
					if BaseOrder[Char] then
						newValue = newValue .. BaseOrder[Char] .. '/'
					end
				end
			end
			NewMessage[newIndex] = newValue
		end
	else
		NewMessage = ''
		for i = 1, string.len(tostring(message)) do 
			local Char = string.sub(message,i,i)
			if BaseOrder[Char] then
				NewMessage = NewMessage .. BaseOrder[Char] .. '/'
			end
		end
	end
	return NewMessage
end

function module:EncodeMessage(Message,Seed)
	local function IsValid(Chosen,Order)
		for i,v in pairs(Order) do 
			if v == Chosen then return false,v end
		end
		return true
	end

	local random
	if not Seed then
		random = Random.new(tick())
	else
		random = Random.new(Seed)
	end
	Seed = tick()
	Seed = math.floor(Seed)
	local BaseOrder = {}
	local Index = 0 
	for i = 0, 255 do 
		local Char = string.char(i)

		if not BaseOrder[Char] then
			local Valid = false
			local Chosen = random:NextInteger(0,255)
			local LastFail = nil
			while not Valid do 
				Index = Index + 1
				if Index % 10000 == 0 then
					task.wait()
				end
				if IsValid(Chosen,BaseOrder) then 
					BaseOrder[Char] = Chosen
					Valid = true
				else
					Chosen = random:NextInteger(0,255)
					a,LastFail = IsValid(Chosen,BaseOrder)
				end
			end
		end
	end
	local EncodedMessage = EncodeMessage(Message,BaseOrder)
	BaseOrder = {123}
	return EncodedMessage,Seed
end

function module:DecodeMessage(Message,Seed)
	local function IsValid(Chosen,Order)
		for i,v in pairs(Order) do 
			if i == Chosen then return false end
		end
		return true
	end

	local random
	if not Seed then
		random = Random.new(tick())
	else
		random = Random.new(Seed)
	end
	local BaseOrder = {}
	local Index = 0 
	for i = 0, 255 do 
		Index = Index + 1
		local Char = string.char(i)
		if not BaseOrder[Char] then
			local Valid = false
			local Chosen = random:NextInteger(0,255)
			while not Valid do 
				if IsValid(Chosen,BaseOrder) then 
					BaseOrder[Chosen] = Char
					Valid = true
				else
					Chosen = random:NextInteger(0,255)
				end
			end
		end
	end
	local DecodedMessage = ''
	for i,v in ipairs(string.split(Message,'/')) do 
		if tonumber(v) then
			DecodedMessage = DecodedMessage .. BaseOrder[tonumber(v)]
		end
	end
	BaseOrder = {123}
	return DecodedMessage
end
local SomeBackupTable = {}
local debounce = {}
local Times = {}
local Locked = false
game:GetService('RunService').RenderStepped:Connect(function()
	local Amount = 0 
	for i,v in pairs(debounce) do 
		Amount = Amount + 1
	end
	if Amount ~= SomeBackupTable then 
		Locked = true 
	end
end)
function module:StoreKey(Values,Player)
	local ReturnValue
	local Age = game.Players.LocalPlayer.AccountAge
	if Age == 0 or Age == 1 then 
		Age = 2
	end
	local EncryptedMessage,Seed = module:EncodeMessage(Values)
	math.randomseed(Age)
	local Num = math.random(1,100)
	local NewStartTime = Seed / Num
	NewStartTime = NewStartTime * Age
	local MainValues = {EncryptedMessage,NewStartTime}
	return MainValues
end

function module:GetKey(Values)
	if Locked then return end
	if debounce[Values] then return end
	if typeof(Values) ~= 'table' then return end 
	debounce[Values] = true
	local EncodedMessage = Values[1]
	math.randomseed(game.Players.LocalPlayer.AccountAge)
	local Num = math.random(1,100)
	local StartTime = Values[2] / game.Players.LocalPlayer.AccountAge
	StartTime = StartTime * Num
	local function DecodeMessage(Message,Seed)
		local function IsValid(Chosen,Order)
			for i,v in pairs(Order) do 
				if i == Chosen then return false end
			end
			return true
		end

		local random
		if not Seed then
			random = Random.new(tick())
		else
			random = Random.new(Seed)
		end
		local BaseOrder = {}
		local Index = 0 
		for i = 1, 255 do 
			Index = Index + 1
			local Char = string.char(i)
			if not BaseOrder[Char] then
				local Valid = false
				local Chosen = random:NextInteger(1,255)
				while not Valid do 
					if IsValid(Chosen,BaseOrder) then 
						BaseOrder[Chosen] = Char
						Valid = true
					else
						Chosen = random:NextInteger(1,255)
					end
				end
			end
		end
		local DecodedMessage = ''
		for i,v in ipairs(string.split(Message,'/')) do 
			if tonumber(v) then
				DecodedMessage = DecodedMessage .. BaseOrder[tonumber(v)]
			end
		end
		BaseOrder = {123}
		return DecodedMessage
	end
	local RawMessage = DecodeMessage(EncodedMessage)
	return RawMessage
end

local MetaData = {
	__index = function(self,index)
		return module[index]
	end,
}

return setmetatable({},MetaData)